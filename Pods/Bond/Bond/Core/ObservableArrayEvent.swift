//
//  The MIT License (MIT)
//
//  Copyright (c) 2015 Srdan Rasic (@srdanrasic)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

/// Abstraction over an event type generated by a ObservableArray.
/// ObservableArray event encapsulates current state of the array, as well
/// as the operation that has triggered an event.
public protocol ObservableArrayEventType {
  associatedtype ObservableArrayEventSequenceType: Sequence
  var sequence: ObservableArrayEventSequenceType { get }
  var operation: ObservableArrayOperation<ObservableArrayEventSequenceType.Iterator.Element> { get }
}

/// A concrete array event type.
public struct ObservableArrayEvent<ObservableArrayEventSequenceType: Sequence>: ObservableArrayEventType {
  public let sequence: ObservableArrayEventSequenceType
  public let operation: ObservableArrayOperation<ObservableArrayEventSequenceType.Iterator.Element>
}

/// Represents an operation that can be applied to a ObservableArray.
/// Note: Nesting of the .Batch operations is not supported at the moment.
public indirect enum ObservableArrayOperation<ElementType> {
  case insert(elements: [ElementType], fromIndex: Int)
  case update(elements: [ElementType], fromIndex: Int)
  case remove(range: CountableRange<Int>)
  case reset(array: [ElementType])
  case batch([ObservableArrayOperation<ElementType>])
}

/// A array event change set represents a description of the change that 
/// the array event operation does to a array in a way suited for application
/// to the UIKit collection views like UITableView or UICollectionView
public enum ObservableArrayEventChangeSet {
  case inserts(Set<Int>)
  case updates(Set<Int>)
  case deletes(Set<Int>)
}

public func ==(lhs: ObservableArrayEventChangeSet, rhs: ObservableArrayEventChangeSet) -> Bool {
  switch (lhs, rhs) {
  case (.inserts(let l), .inserts(let r)):
    return l == r
  case (.updates(let l), .updates(let r)):
    return l == r
  case (.deletes(let l), .deletes(let r)):
    return l == r
  default:
    return false
  }
}

public extension ObservableArrayOperation {
  
  /// Maps elements encapsulated in the operation.
  public func map<X>(_ transform: (ElementType) -> X) -> ObservableArrayOperation<X> {
    switch self {
    case .reset(let array):
      return .reset(array: array.map(transform))
    case .insert(let elements, let fromIndex):
      return .insert(elements: elements.map(transform), fromIndex: fromIndex)
    case .update(let elements, let fromIndex):
      return .update(elements: elements.map(transform), fromIndex: fromIndex)
    case .remove(let range):
      return .remove(range: range)
    case .batch(let operations):
      return .batch(operations.map{ $0.map(transform) })
    }
  }
  
  public func filter(_ includeElement: (ElementType) -> Bool, pointers: inout [Int]) -> ObservableArrayOperation<ElementType>? {
    
    switch self {
    case .insert(let elements, let fromIndex):
      
      for (index, element) in pointers.enumerated() {
        if element >= fromIndex {
          pointers[index] = element + elements.count
        }
      }
      
      var insertedIndices: [Int] = []
      var insertedElements: [ElementType] = []
      
      for (index, element) in elements.enumerated() {
        if includeElement(element) {
          insertedIndices.append(fromIndex + index)
          insertedElements.append(element)
        }
      }
      
      if insertedIndices.count > 0 {
        let insertionPoint = startingIndexForIndex(fromIndex, forPointers: pointers)
        pointers.insert(contentsOf: insertedIndices, at: insertionPoint)
        return .insert(elements: insertedElements, fromIndex: insertionPoint)
      }
      
    case .update(let elements, let fromIndex):
      
      var operations: [ObservableArrayOperation<ElementType>] = []
      
      for (index, element) in elements.enumerated() {
        let realIndex = fromIndex + index
        
        // if element on this index is currently included in filtered array
        if let location = pointers.index(of: realIndex) {
          if includeElement(element) {
            // update
            operations.append(.update(elements: [element], fromIndex: location))
          } else {
            // remove
            pointers.remove(at: location)
            operations.append(.remove(range: location..<location+1))
          }
        } else { // element in this index is currently NOT included
          if includeElement(element) {
            // insert
            let insertionPoint = startingIndexForIndex(realIndex, forPointers: pointers)
            pointers.insert(realIndex, at: insertionPoint)
            operations.append(.insert(elements: [element], fromIndex: insertionPoint))
          } else {
            // not contained, not inserted - do nothing
          }
        }
      }
      
      if operations.count == 1 {
        return operations.first!
      } else if operations.count > 1 {
        return .batch(operations)
      }
      
    case .remove(let range):
      
      var startIndex = -1
      var endIndex = -1
      
      for (index, element) in pointers.enumerated() {
        if element >= range.startIndex {
          if element < range.endIndex {
            if startIndex < 0 {
              startIndex = index
              endIndex = index + 1
            } else {
              endIndex = index + 1
            }
          }
          
          pointers[index] = element - range.count
        }
      }
      
      if startIndex >= 0 {
        let removedRange = Range(startIndex..<endIndex)
        pointers.removeSubrange(removedRange)
        return .remove(range: CountableRange(removedRange))
      }
      
    case .reset(let array):
      pointers = pointersFromSequence(array, includeElement: includeElement)
      return .reset(array: array.filter(includeElement))
      
    case .batch(let operations):
      
      var filteredOperations: [ObservableArrayOperation<ElementType>] = []
      
      for operation in operations {
        if let filtered = operation.filter(includeElement, pointers: &pointers) {
          filteredOperations.append(filtered)
        }
      }
      
      if filteredOperations.count == 1 {
        return filteredOperations.first!
      } else if filteredOperations.count > 0 {
        return .batch(filteredOperations)
      }
    }
    
    return nil
  }
  
  /// Generates the `ObservableArrayEventChangeSet` representation of the operation.
  public func changeSet() -> ObservableArrayEventChangeSet {
    switch self {
    case .insert(let elements, let fromIndex):
      return .inserts(Set(fromIndex..<fromIndex+elements.count))
    case .update(let elements, let fromIndex):
      return .updates(Set(fromIndex..<fromIndex+elements.count))
    case .remove(let range):
      return .deletes(Set(range))
    case .reset:
      fallthrough
    case .batch:
      fatalError("Dear Sir/Madam, I cannot generate changeset for \(self) operation.")
    }
  }
}

internal func pointersFromSequence<S: Sequence>(_ sequence: S, includeElement: (S.Iterator.Element) -> Bool) -> [Int] {
  var pointers: [Int] = []
  for (index, element) in sequence.enumerated() {
    if includeElement(element) {
      pointers.append(index)
    }
  }
  return pointers
}

internal func startingIndexForIndex(_ x: Int, forPointers pointers: [Int]) -> Int {
  var idx: Int = -1
  for (index, element) in pointers.enumerated() {
    if element < x {
      idx = index
    } else {
      break
    }
  }
  return idx + 1
}

public func operationOffset<T>(_ operation: ObservableArrayOperation<T>) -> Int {
  switch operation {
  case .insert(let elements, _):
    return elements.count
  case .remove(let range):
    return -range.count
  default:
    return 0
  }
}

public func operationStartIndex<T>(_ operation: ObservableArrayOperation<T>) -> Int {
  switch operation {
  case .insert(_, let fromIndex):
    return fromIndex
  case .remove(let range):
    return range.startIndex
  default:
    return 0
  }
}

/// This function is used by UICollectionView and UITableView bindings. Batch operations are expected to be sequentially
/// applied to the array/array, which is not what those views do. The function converts operations into a "diff" discribing
/// elements at what indices changed and in what way.
///
/// Expected order: .Deletes, .Inserts, .Updates
///
/// Deletes are always indexed in the index-space of the original array
///  -> Deletes are shifted by preceding inserts and deletes at lower indices
/// Deletes of updated items are substracted from updates set
/// Deletes of inserted items are substracted from inserts set
/// Deletes shift preceding inserts at higher indices
///
/// Inserts are always indexed in the index-space of the final array
/// -> Inserts shift preceding inserts at higher indices
///
/// Updates are always indexed in the index-space of the original array
///  -> Updates are shifted by preceding inserts and deletes at lower indices
/// Updates of inserted items are annihilated
///
public func changeSetsFromBatchOperations<T>(_ operations: [ObservableArrayOperation<T>]) -> [ObservableArrayEventChangeSet] {
  
  var inserts = Set<Int>()
  var updates = Set<Int>()
  var deletes = Set<Int>()
  
  for (operationIndex, operation) in operations.enumerated() {
    switch operation {
    case .insert(let elements, let fromIndex):
      // Inserts are always indexed in the index-space of the array as it will look like when all operations are applies
      
      // Inserts shift preceding inserts at higher indices
      inserts = Set(inserts.map { $0 >= fromIndex ? $0 + elements.count : $0 })
      
      inserts.formUnion(fromIndex..<fromIndex+elements.count)
      
    case .update(let elements, let fromIndex):
      // Updates are always indexed in the index-space of the array before any operation is applied

      // Updates done to the elements that were inserted in this batch must be discared
      var newUpdates = Array(Set(fromIndex..<fromIndex+elements.count).subtracting(inserts))

      // Any prior insertion or deletion shifts our indices
      for insert in inserts {
        newUpdates = newUpdates.map { $0 >= insert ? $0 - 1 : $0 }
      }
      
      for delete in deletes {
        newUpdates = newUpdates.map { $0 >= delete ? $0 + 1 : $0 }
      }
      
      updates.formUnion(newUpdates)
      
    case .remove(let range):
      // Deletes are always indexed in the index-space of the array before any operation is applied
      
      let possibleNewDeletes = Set(range)
      
      // Elements that were inserted and then removed in this batch must be discared
      let annihilated = inserts.intersection(possibleNewDeletes)
      inserts.subtract(annihilated)
      
      let actualNewDeletes = possibleNewDeletes.subtracting(annihilated)
      
      // Deletes are shifted by preceding inserts and deletes at lower indices
      var correctionOffset = 0
      for operation in operations.prefix(upTo: operationIndex) {
        if range.startIndex >= operationStartIndex(operation) {
          correctionOffset -= operationOffset(operation)
        }
      }
      
      let newDeletes = actualNewDeletes.map { $0 + correctionOffset }
      deletes.formUnion(newDeletes)
      
      // Elements that were updated and then removed in this batch must be discared
      updates.subtract(newDeletes)

      // Deletes shift preceding inserts at higher indices
      inserts = Set(inserts.map { $0 >= range.startIndex ? $0 - range.count : $0 })
      
    case .reset:
      fatalError("Dear Sir/Madam, the .Reset operation within the .Batch is not supported at the moment!")
    case .batch:
      fatalError("Dear Sir/Madam, nesting the .Batch operations is not supported at the moment!")
    }
  }
  
  var changeSets: [ObservableArrayEventChangeSet] = []
  
  if deletes.count > 0 {
    changeSets.append(.deletes(deletes))
  }
  
  if inserts.count > 0 {
    changeSets.append(.inserts(inserts))
  }
  
  if updates.count > 0 {
    changeSets.append(.updates(updates))
  }
  
  return changeSets
}
